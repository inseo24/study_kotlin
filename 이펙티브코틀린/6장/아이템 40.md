# 아이템 40 : equals의 규약을 지켜라

코틀린의 Any에는 다음과 같이 잘 설정된 규약들을 가진 메서드들이 있습니다.

- equals
- hashCode
- toString

위 메서드들은 규약을 위반했을 때, 일부 객체 또는 기능이 제대로 동작하지 않을 수도 있습니다. 

### 동등성

코틀린에는 두 가지 종류의 동등성이 있습니다.(equality)

- 구조적 동등성(structural equality) : equals 메서드와 이를 기반으로 만들어진 == 연산자를 확인하는 동등성. nulllable일 경우 알아서 ?. ?: 가 적용됨
- 레퍼런스적 동등성(referential equality) : === 연산자로 확인하는 동등성. 두 피연산자가 같은 객체를 가리키면 true 리턴.

equals는 Any에 구현되어 있어 모든 객체에서 사용할 수 있으나, 다만 연산자를 사용해서 다른 타입의 두 객체를 비교하는 것은 허용되지 않습니다.

```kotlin
open class Animal
class Book
Animal() == Book() // error
Animal() === Book() // error
```

물론 다음과 같이 같은 타입을 비교하거나, 둘이 상속 관계를 갖는 경우에는 비교할 수 있습니다.

```kotlin
class Cat: Animal()
Animal() == Cat() // 가능
Animal() === Cat() // 가능
```

### 왜 equals가 필요할까

Any 클래스에 구현된 equals 메서드는 디폴트로 ===처럼 두 인스턴스가 완전히 같은 객체인지 비교한다. 

이는 모든 객체는 디폴트로 유일한 객체라는 걸 의미한다.

→ 이런 동작은 db 연결, 리포지터리, 스레드 등 active element를 활용할 때 유용합니다.

하지만 동등성을 약간 다른 형태로 표현해야 하는 객체가 있습니다.

예를 들어, 두 객체가 기본 생성자의 프로퍼티가 같다면, 같은 객체로 보는 형태가 있을 수 있습니다. data 한정자를 붙여서 데이터 클래스로 정의하면, 자동으로 이와 같은 동등성으로 동작합니다.

이렇게 data 한정자를 기반으로 동등성의 동작을 조작할 수 있으므로, 일반적으로 코틀린에서는 equals를 직접 구현할 필요가 없습니다. 

다만 상황에 따라 equals를 직접 구현해야 하는 경우가 있을 수도 있습니다. 

- 기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우
- 일부 프로티만으로 비교해야 하는 경우
- data 한정자를 붙이는 걸 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는 경우

### equals 의 규약

코틀린 1.4.31 기준으로 equals 에는 다음과 같은 주석이 달려 있습니다.

어떤 다른 객체가 이 객체와 같은지를 확인할 때 사용한다.

구현은 반드시 아래와 같은 요구사항을 충족해야 한다.

- reflexive 동작 : x가 null이 아닌 값이라면, x.equals(x)는 true를 리턴함
- symmetric 동작 : x와 y가 널이 아닌 값이라면, x.equals(y)는 y.equals(x)와 같은 결과를 출력해야 한다.
- transitive 동작 : x, y, z가 널이 아닌 값이고, x.equals(y)와 y.equals(z)가 true면, x.equals(z)도 true여야 한다.
- 일관적 동작 : x, y가 널이 아닌 값이라면, x.equals(y)는 여러 번 실행하더라도 항상 같은 결과를 리턴해야 한다.
- 널과 관련된 동작: x가 널이 아닌 값이라면, x.equals(null)은 항상 false를 리턴해야 한다.

추가로, equals, toString, hashCode의 동작이 매우 빠를 것으로 예측되므로, 빠르게 동작해야 한다.

이는 공식 문서에 없는 규약이지만, 두 요소가 같은지 확인하는 동작에 몇 초가 걸리는지는 일반적으로 예측하지 못하는 동작이다. 

위 요구사항들은 자바 때부터 정의되었으며, 코틀린에서도 그대로 정의된 내용입니다. 따라서 수많은 객체가 이런 동작에 의존해서 만들어졌습니다.