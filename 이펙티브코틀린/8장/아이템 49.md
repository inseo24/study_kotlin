# 아이템 49 : 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라

```kotlin
interface Iterable<out T> { 
	operator fun iterator(): Iterator<T>
}

interface Sequence<out T> {
	operator fun iterator(): Iterator<T>
}
```

코드를 보면 Iterable과 Sequence의 차이는 이름 밖에 없는게 아닌가 할 수 있으나, 둘은 완전히 다른 목적으로 설계되어 완전히 다른 형태로 작동합니다.

무엇보다 **Sequence는 lazy 처리**됩니다. 따라서 시퀀스 처리 함수들을 사용하면, **데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴됩니다**. **최종적인 계산은 toList 또는 count 등의 최종 연산이 이뤄질 때 수행됩니다**. 반면, **Iterable은 처리 함수를 사용할 때마다 연산이 이뤄져 List가 만들어집니다.**

```kotlin
public inline fun <T> Iterable<T>.filter(
	predicate: (T) -> Boolean
): List<T> {
	return filterTo(ArrayList<T>(), predicate)
}

public fun <T> Sequence<T>.filter(
	predicate: (T) -> Boolean
): Sequence<T> {
	return FilteringSequence(this, true, predicate)
}
```

컬렉션 처리 연산은 호출될 때 연산이 이뤄집니다. 반면, 시퀀스 처리 함수는 최종 연산이 이뤄지기 전까지는 각 단계에서 연산이 일어나지 않습니다. 예를 들어, 시퀀스 처리 함수 filter는 중간 연산입니다. 따라서 어떤 연산 처리도 하지 않고, **기존의 시퀀스를 필터링하는 데코레이터만 설치합니다. 실질적인 필터링 처리는 toList 등과 같은 최종 연산을 할 때 이뤄집니다.**

```kotlin
val seq = sequenceOf(1, 2, 3)
val filtered = seq.filter { print("f$it "); it % 2 == 1 }
println(filtered) // FilteringSequence@...

val asList = filtered.toList()
// f1 f2 f3
println(asList) // [1, 3]

val list = listOf(1, 2, 3)
val listFiltered = list
	.filter { print("f$it "); it % 2 == 1 }
// f1 f2 f3
println(listFilterd)
```

이와 같이 시퀀스의 지연 처리는 다음과 같은 장점을 갖습니다.

- 자연스러운 처리 순서를 유지합니다.
- 최소한만 연산합니다.
- 무한 시퀀스 형태로 사용할 수 있습니다.
- 각각의 단계에서 컬렉션을 만들어 내지 않습니다.

각각의 장점을 하나씩 살펴봅시다.

### 순서의 중요성

이터러블 처리와 시퀀스 처리는 연산의 순서가 달라지면, 다른 결과가 나옵니다. **시퀀스 처리는 요소 하나하나에 지정한 연산을 한꺼번에 적용합니다.** 이를 전문적으로 element-by-element order or lazy order라고 부릅니다. 반면, **이터러블은 요소 전체를 대상으로 연산을 차근차근 적용해 나갑니다**. 이를 전문적으로 step-by-step order 또는 eager order 라고 합니다.

```kotlin
sequenceOf(1, 2, 3)
		.filter { print("F$it, "); it % 2 == 1 }
		.map { print("M$it, "); it * 2 }
		.forEach { print("E$it, ") }
// 출력 : F1, M1, E2, F2, F3, M3, E6

listOf(1, 2, 3)
		.filter { print("F$it, "); it % 2 == 1 }
		.map { print("M$it, "); it * 2 }
		.forEach { print("E$it, ") }
// 출력 : F1, F2, F3, M1, M3, E2, E6
```

컬렉션 처리 함수를 사용하지 않고, 고전적인 반복문과 조건문을 활용해서 다음과 같은 코드를 구현한다면, 이는 시퀀스 처리인 element-by-element order와 같습니다.

```kotlin
for (e in listOf(1,2,3)) {
	print("F$e, ")
	if (e % 2 == 1) {
		print("M$e, ")
		val mapped = e * 2
		print("E$mapped, ")
	}
}
// 출력 : F1, M1, E2, F2, F3, M3, E6
```

따라서 시퀀스 처리에서 사용되는 element-by-element order가 훨씬 자연스러운 처리라고 할 수 있습니다. 또한 시퀀스 처리는 기본적인 반복문과 조건문을 사용하는 코드와 같으므로, 아마도 조만간 낮은 레벨 컴파일러 최적화가 처리를 더 빠르게 해줄 것입니다.

### 최소 연산

이터러블은 중간 연산이 없어, 원하는 처리를 컬렉션 전체에 적용합니다.

시퀀스는 중간 연산이 있어 원하는 요소에만 처리를 적용할 수 있습니다.

**중간 처리 단계를 모든 요소에 적용할 필요가 없는 경우 시퀀스를 사용하는 것이 좋습니다.**

**find처럼 처리를 적용하고 싶은 요소를 선택하는 연산으로는 first, take, any, all, none, indexOf가 있습니다.**

### 무한 시퀀스

시퀀스는 실제로 최종 연산이 일어나기 전까지는 컬렉션에 어떤 처리도 하지 않습니다. 따라서 무한 시퀀스를 만들고, 필요한 부분까지만 값을 추출하는 것도 가능합니다. 

무한 시퀀스를 만드는 일반적인 방법은 generateSequence 또는 sequence를 사용하는 것입니다. 

먼저 generateSequence는 ‘첫 번째 요소'와 ‘그 다음 요소를 계산하는 방법'을 지정해야 합니다.

```kotlin
generateSequence(1) { it + 1 }
	.map { it * 2 }
	.take(10)
	.forEach { print("$it, ") }
// 2, 4, 6, 7, 10, 12, 14, 16, 18, 20
```

두 번째로 sequence는 중단 함수(suspending function, 코루틴*)로 요소들을 지정합니다.

시퀀스 빌더는 중단 함수 내부에서 yield로 값을 하나씩 만들어 냅니다. 

*여기서 코루틴은 병렬/동시 코루틴이 아닌, 시퀀셜 코루틴입니다. **시퀀셜 코루틴은 스레드를 변경하지 않고, 단순하게 함수를 중간에 중단하는 기능만을 활용하는 코루틴입니다.**

```kotlin
val fibonacci = sequence {
	yield(1)
	var current = 1
	var prev = 1
	while (true) {
		yield(current)
		val temp = prev
		prev = current
		current += temp
	}
}

print(fibonacci.take(10).toList())
// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

참고로 무한 시퀀스를 실제 사용할 때는 값을 몇 개 활용할지 지정해야 합니다. 그렇지 않으면 무한하게 반복합니다. 

```kotlin
print(fibonacci.toList()) // 종료되지 않음
```

 

따라서 이전 코드처럼 take을 쓰거나, first, find, any, all, none, indexOf 같이 일부 요소만 선택하는 종결 연산을 활용해야 합니다. 이를 구할 때도 이전 절과 마찬가지로 모든 요소를 처리하지 않으므로 시퀀스가 이터러블보다 훨씬 더 효율적입니다. 다만 실제로 사용해 보면, 생각보다 무한 반복에 빠지는 경우가 많습니다. any는 true를 리턴하지 못하면, 무한 반복에 빠집니다. 마찬가지로 all, none은 false를 리턴하지 못하면 무한 반복에 빠집니다.

**결과적으로 무한 시퀀스는 종결 연산으로 take, first 정도만 사용하는 것이 좋습니다.**

### 각각의 단계에서 컬렉션을 만들어 내지 않음

표준 컬렉션 처리 함수는 각각의 단계에서 새로운 컬렉션을 만들어 냅니다. 일반적으로 대부분 List입니다. 각각의 단계에서 만들어진 결과를 활용하거나 저장할 수 있다는 것은 컬렉션의 장점이지만, 각각의 단계에서 결과가 만들어지면서 공간을 차지하는 비용이 든다는 것은 큰 단점입니다.

```kotlin
numbers
	.filter { it % 10 == 0 } // 여기서 컬렉션 하나
	.map { it * 2 } // 여기서 컬렉션 하나
	.sum()
// 전체적으로 2개의 컬렉션이 만들어집니다

numbers
	.asSequence()
	.filter { it % 10 == 0 }
	.map { it * 2 }
	.sum()
// 컬렉션이 만들어지지 않습니다
```

크거나 무거운 컬렉션을 처리할 때는 큰 비용이 들어갑니다. 일반적으로 파일을 처리할 때는 시퀀스를 활용합니다. 

컬렉션 처리의 각각의 단계에서 새로운 컬렉션을 만드는 데는 비용이 들어갑니다. 크기가 큰 요소를 처리할수록 비용이 커집니다. 처리 단계가 하나 정도라면, 컬렉션 처리와 시퀀스 처리의 차이가 크지 않습니다. 하지만 처리 단계가 많아질수록 이런 차이가 커지므로, 큰 컬렉션으로 여러 처리 단계를 거쳐야 한다면, 컬렉션 처리보다는 시퀀스 처리를 사용하는 것이 좋습니다.

이 문자에서 큰 컬렉션이란 요소를 많이 갖는 무거운 컬렉션을 말합니다. 수만개의 요소를 가진 정수 리스트일 수 도 있습니다. 또한 일반적인 상황은 아니지만 몇 MB나 되는 긴 문자열이 몇 개 들어 있는 리스트일 수도 있습니다. 여러 처리 단계란 여러 함수를 사용한다는 의미입니다. 예를 들어 다음 코드를 살펴봅시다.

```kotlin
fun singleStepListProcessing(): List<Product> {
	return productList.filter { it.bought }
}

fun singleSequenceProcessing(): List<Product> {
	return productList.asSequence()
					.filter { it.bought }
					.toList()
}
```

일반적으로 코드 실행의 성능에 큰 차이는 없습니다.(filter 함수가 inline이므로 간단한 리스트 처리에서는 좀 더 빠릅니다.) 하지만 큰 규모의 컬렉션에 filter 함수를 사용하고 나서 map 함수를 사용하는 등의 더 많은 처리 단계를 넣으면 차이를 확인할 수 있습니다. 

하나 이상의 처리 단계를 포함하는 컬렉션 처리는 20~40% 정도의 성능이 향상됩니다.

### 시퀀스가 빠르지 않은 경우

컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀀스를 사용해도 빨라지지 않습니다. **현재 유일한 예로 코틀린 stdlib의 sorted가 있습니다. sorted는 Sequence를 List로 변환한 뒤에, 자바 stdlib의 sort를 사용해 처리합니다. 문제는 이런 변환 처리로 시퀀스가 컬렉션 처리보다 느려진다는 것입니다.**

참고로 무한 시퀀스처럼 시퀀스의 다음 요소를 lazy하게 구하는 시퀀스에 sorted를 적용하면, 무한 반복에 빠지는 문제가 있습니다. 그래서 시퀀스에서 sorted를 빼야 한다는 의견도 있지만, 정렬 처리는 일반적으로 사용되는 처리이므로, 시퀀스에도 들어간 것입니다. 

**따라서 무한 시퀀스에 sorted를 사용할 수 없다는 결함은 따로 기억해야 합니다.**

```kotlin
generateSequence(0) { it + 1 }.take(10).sorted().toList()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
generateSequence(0) { it + 1 }.sorted().take(10).toList()
// 종료되지 않음, 어떤 값도 리턴되지 않음
```

sorted는 시퀀스보다 컬렉션이 더 빠른 희귀한 예입니다. 다른 처리는 모두 시퀀스가 빠르므로 여러 처리가 결합된 경우 컬렉션보다 시퀀스를 사용하는 것이 더 빠릅니다.

### 자바 스트림의 경우

자바 8의 스트림도 lazy하게 작동하며, 마지막 처리 단계에서 연산이 일어납니다. 다만 자바의 스트림과 코틀린의 시퀀스는 다음과 같은 세 가지 큰 차이점이 있습니다.

- 코틀린의 시퀀스가 더 많은 처리 함수를 갖고 있습니다. 사용하기 더 쉽습니다. (코틀린 시퀀스가 몇 가지 문제를 해결했기 때문, 예를 들어 최종 연산을 collect(Collectros.toList())가 아닌 toList()처럼 간단하게 할 수 있습니다.)
- 자바 스트림은 병렬 함수를 사용해 병렬 모드를 실행할 수 있습니다. 이는 멀티 코어 환경에서 굉장히 큰 성능향상을 가져옵니다. 다만 몇 가지 결함이 있습니다.(병렬 함수 내부에서 사용하는 common join-fork 스레드 풀과 관련된 이슈가 있습니다. 병렬로 처리되는 작업이 독립적인 처리가 아니라면, 성능에 문제가 발생합니다.)
- 코틀린의 시퀀스는 코틀린/JVM, 코틀린/JS, 코틀린/네이티브 등의 일반적인 모듈에서 모두 사용할 수 있습니다. 하지만 자바 스트림은 코틀린/JVM에서만 동작하며, 그것도 JVM 8 버전 이상일 때만 동작합니다.

일반적으로 병렬 모드를 사용하지 않는다면 자바 스트림과 코틀린 시퀀스 중에 어떤 것이 더 효율적이라고 단정지어서 이야기하기 어렵습니다. 필자의 개인 경험으로 병렬 모드로 성능적 이득을 얻을 수 있는 경우에만 자바 스트림을 사용하고, 이외의 경우 일반적인 경우에는 코틀린 시퀀스를 사용하는 것이 좋다고 생각합니다. 

### 코틀린 시퀀스 디버깅

코틀린 시퀀스와 자바 스트림은 모두 단계적으로 요소와 흐름을 추적할 수 있는 디버깅 기능을 지원합니다. 자바 스트림은 ‘Java Stream Debugger’라는 이름의 플러그인, 코틀린은 ‘Kotlin Sequence Debugger’라는 이름의 플러그인으로 이를 활용할 수 있습니다. 참고로 코틀린 시퀀스 디버거는 코틀린 플러그인에 통합되어 있습니다. 

### 정리

컬렉션과 시퀀스는 같은 처리 메서드를 지원하며, 사용하는 형태가 거의 비슷합니다. 

일반적으로 데이터를 컬렉션에 저장하므로, 시퀀스 처리를 하려면 시퀀스를 변환하는 과정이 필요합니다. 또한 최종적으로 컬렉션 결과를 원하는 경우가 많으므로, 시퀀스를 다시 컬렉션으로 변환하는 과정도 필요합니다. 이것이 시퀀스 처리의 단점이라고 할 수 있습니다. 하지만 시퀀스는 lazy하게 처리됩니다. 

이로 인해서 다음과 같은 장점이 발생합니다.

- 자연스러운 처리 순서를 유지합니다.
- 최소한만 연산합니다.
- 무한 시퀀스 형태로 사용할 수 있습니다.
- 각각의 단계에서 컬렉션을 만들어 내지 않습니다.

결과적으로 무거운 객체나 규모가 큰 컬렉션을 여러 단계에 걸쳐서 처리할 때는 시퀀스를 사용하는 것이 좋습니다. 또한 시퀀스 처리는 ‘Kotlin Sequence Debugger’ 플러그인을 활용해 처리 단계를 시각적으로 확인할 수 있습니다. 상황에 따라 시퀀스 처리를 활용하면 큰 성능 향상이 있을 수 있습니다.v