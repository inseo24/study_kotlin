다음과 같은 제네릭 클래스가 있다고 합시다. 

```kotlin
Class Cup<T>
```

위의 코드에서 타입 파라미터 T는 variance 한정자(out 또는 in)가 없으므로, 기본적으로 invariant(불공변성)입니다. invariant는 제네릭 타입으로 만들어진 타입들이 서로 관련성이 없다는 의미입니다. 예를 들어 Cup<Int>와 Cup<Number>, Cup<Any>, Cup<Nothing>은 어떤 관련성도 갖지 않습니다.

```kotlin
fun main() {
	val anys: Cup<Any> = Cup<Int>() // error: Type mismatch
	val nothings: Cup<Nothing> = Cup<Int>() // error
}
```

만약에 어떤 관련성을 원한다면, out 또는 in이라는 variance 한정자를 붙입니다. 

out은 타입 파라미터를 **covariant(공변성)**로 만듭니다. 이는 **A가 B의 서브 타입일 때, Cup<A>가 Cup<B>의 서브 타입이라는 의미입니다.**

```kotlin
class Cup<out T>
open class Dog
class Puppy: Dog()

fun main(args: Array<String>) {
	val b: Cup<Dog> = Cup<Puppy>() // OK Puppy가 Dog의 서브 타입
	val a: Cup<Puppy> = Cup<Dog>() // error
	
	val anys: Cup<Any> = Cup<Int>() // OK
	val nothings: Cup<Nothing> = Cup<int> // error
}
```

in 한정자는 반대 의미입니다. in 한정자는 타입 파라미터를 **contravariant(반변성)**으로 만듭니다. **이는 A가 B의 서브타입일 때, Cup<A>가 Cup<B>의 슈퍼타입이라는 것을 의미한다.**

```kotlin
class Cup<in T>
open class Dog
class Puppy(): Dog()

fun main(args: Array<String>) {
	val b: Cup<Dog> = Cup<Puppy>() // error
	val a: Cup<Puppy> = Cup<Dog>() // OK
	
	val anys: Cup<Any> = Cup<Int>() // error
	val nothings: Cup<Nothing> = Cup<int> // OK
}
```

### 함수 타입

함수 타입은 파라미터 유형과 리턴 타입에 따라서 서로 어떤 관계를 갖습니다.

예를 들어 Int를 받고, Any를 리턴하는 함수를 파라미터로 받는 함수를 생각해봅시다.

```kotlin
fun printProcessedNumber(transition: (Int)->Any) {
	print(transition(42))
}
```

(Int)→Any 타입의 함수는 (Int)→Number, (Number)→Any, (Number)→Number, (Number)→Int 등으로도 작동합니다.

```kotlin
val intToDouble: (Int) -> Number = { it.toDouble() }
val numberAsText: (Number) -> Any = { it.toShort() }
val identity: (Number) -> Number = { it }
val numberToInt: (Number) -> Int = { it.toInt() }
val numberHash: (Any) -> Number = { it.hashCode() }
```

타입 시스템 계층에서 파라미터 타입이 더 높은 타입으로 이동하고, 리턴 타입은 계층 구조의 더 낮은 타입으로 이동한다. (ex) 파라미터 타입은 Int → Number → Any로 이동, Any → Number → Int로 슈퍼타입이 된다) 

코틀린 함수 타입의 모든 파라미터 타입은 contravariant입니다. 또한 모든 리턴 타입은 covariant입니다. 다음 그림을 보면 in과 out을 표시했습니다.

함수 타입을 사용할 때는 이처럼 자동으로 variance 한정자가 사용됩니다.

코틀린에서 자주 사용되는 것으로는 convariant(out 한정자)를 가진 List가 있습니다. 이는 variance 한정자가 붙지 않은 MutableList와 다릅니다. 왜 MutableList보다 List를 더 많이 사용하는지, 그리고 어떤 부분이 다른 것인지 variance 한정자의 안전성과 관련된 내용을 이해하면 알 수 있습니다.

### variance 한전자의 안전성

자바의 배열은 covariant입니다. 이는 배열을 기반으로 제네릭 연산자는 정렬 함수 등을 만들기 위해서라고 이야기 합니다. 그런데 자바의 배열이 covariant라는 속성을 갖기 떄문에 큰 문제가 발생합니다. 간단한 예로 다음 코드를 살펴봅시다. 이 코드는 컴파일 중에 아무런 문제도 없지만, 런타임 오류가 발생합니다. 

```java
// java
Integer[] numbers = {1, 4, 2, 1};
Object[] objects = numbers;
objects[2] = "B"; // runtime error : ArrayStoreException
```

numbers를 Object[]로 캐스팅해도 구조 내부에서 사용되고 있는 실질적인 타입이 바뀌는 것은 아닙니다.(여전히 Integer) 따라서 이런 배열에 String 타입의 값을 할당하면 오류가 발생합니다. 이는 자바의 명백한 결함입니다.

코틀린에서는 이런 결함을 해결하기 위해 Array(IntArray, CharArray 등)를 invariant로 만들었습니다.(따라서 Array<Int>를 Array<Any> 등으로 바꿀 수 없습니다.)

그럼 다음 코드를 살펴봅시다. 파라미터 타입을 예측할 수 있다면, 어떤 서브타입이라도 전달할 수 있습니다. 따라서 아규먼트를 전달할 때, 암묵적으로 업캐스팅할 수 있습니다.

```java
open class Dog
class Puppy: Dog()
class Hound: Dog()

fun takeDog(dog: Dog) {}

takeDog(Dog())
takeDog(Puppy())
takeDog(Hound())
```

이는 covariant하지 않습니다. covariant 타입 파라미터(out)가 in 한정자 위치에 있다면(예를 들어, 타입 파라미터), covariant와 업캐스팅을 연결해서, 우리가 원하는 타입을 아무것이나 전달할 수 있습니다. 즉, value가 매우 구체적인 타입이라 안전하지 않으므로, value를 Dog 타입으로 지정할 경우, String 타입을 넣을 수 없습니다. 

```kotlin
class Box<out T> {
	private var value: T? = null

	// kotlin에선 사용할 수 없는 코드입니다
	fun set(value: T) {
		this.value = value
	}

	fun get(): T = value ?: error("Value not set")
}

val puppyBox = Box<Puppy>()
val dogBox: Box<Dog> = puppyBox
dogBox.set(Hound()) 

val dogHous = Box<Dog>()
val box: Box<Any> = dogHouse
box.set("Some string")
box.set(42)
```

이런 상황은 안전하지 않습니다. 캐스팅 후 실질적인 객체가 그대로 유지되고, 타이핑 시스템에서만 다르게 처리되기 때문입니다. Int를 설정하려고 하는데, 해당 위치는 Dog만을 위한 자리입니다. 만약 이것이 가능하다면, 오류가 발생할 것입니다. 그래서 코틀린은 public in 한정자 위치에 covariant 타입 파라미터(out 한정자)가 오는 것을 금지해 이런 상황을 막습니다. 

```kotlin
class Box<out T> {
	var value: T? = null // error

	fun set(value: T) { // error
		this.value = value
	}

	fun get(): T = value ?: error("Value not set")
}
```

가시성을 private으로 제한하면, 오류가 발생하지 않습니다. 객체 내부에서는 업캐스트 객체에 covariant(out 한정자)를 사용할 수 없기 때문입니다.

```kotlin
class Box<out T> {
	private var value: T? = null
	
	private set(value: T) {
		this.value = value
	}

	fun get(): T = value ?: error("Value not set")
}
```

covariant(out 한정자)는 public out 한정자 위치에서도 안전하므로 따로 제한되지 않습니다. 이런 안전성의 이유로 생성되거나 노출되는 타입에만 covariant(out 한정자)를 사용하는 것입니다. 이런 프로퍼티는 일반적으로 producer 또는 immutable 데이터 홀더에 많이 사용됩니다. 

좋은 예로 T는 covariant인 List<T>가 있습니다. 

여기까지 읽고 드랍

내용을 전혀 이해 못했음

→ 스터디 전에 다시 읽고 모르는 부분 정리해서 스터디 때 물어봐야겠다


+) 내용 추가 예정
PECS

리스트 관점 - 자기가 갖고 있던 원소를 생산하거나, 외부에서 원소에 들어오거나 하는 걸 소비한다고 표현